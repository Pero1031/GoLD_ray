#pragma once

/**
 * @file Material.hpp
 * @brief Abstract interface for physical materials and BxDF functions.
 *
 * This header defines the Material base class, which encapsulates the
 * light-scattering properties of a surface (BSDF). It supports evaluation,
 * importance sampling, and PDF calculation required for robust Monte Carlo
 * path tracing.
 */

#include "Core/Types.hpp"
#include "Core/Forward.hpp"
#include "Core/Assert.hpp"
#include "Core/Interaction.hpp"
#include "Core/Ray.hpp"

#include <optional>

// Include your spectral data handler
// #include "IORInterpolator.hpp" 

namespace rayt {

    /**
     * @brief Flags representing the properties of a BxDF (BSDF/BRDF/BTDF).
     *
     * Used to categorize light scattering behavior, which is essential for
     * Multiple Importance Sampling (MIS) and handling delta distributions
     * (perfect mirrors/glass).
     */
    enum BxDFFlags : uint32_t {
        Unset = 0,              ///< No flags set.
        Reflection = 1u << 0,   ///< Handles reflection (BRDF).
        Transmission = 1u << 1, ///< Handles transmission (BTDF).
        Diffuse = 1u << 2,      ///< Diffuse scattering (Lambertian, etc.).
        Glossy = 1u << 3,       ///< Glossy scattering (Microfacet, etc.).
        Specular = 1u << 4,     ///< Perfect specular scattering (Delta distribution).

        /// Composite flag representing all possible scattering types.
        All = Reflection | Transmission | Diffuse | Glossy | Specular
    };

    /**
     * @brief Bitwise OR operator to combine BxDF flags.
     * @param a First flag.
     * @param b Second flag.
     * @return BxDFFlags The combined flags.
     */
    inline BxDFFlags operator|(BxDFFlags a, BxDFFlags b) {
        return BxDFFlags(uint32_t(a) | uint32_t(b));
    }

    /**
     * @brief Bitwise AND operator to mask or check BxDF flags.
     * @param a First flag.
     * @param b Second flag.
     * @return BxDFFlags The intersected flags.
     */
    inline BxDFFlags operator&(BxDFFlags a, BxDFFlags b) {
        return BxDFFlags(uint32_t(a) & uint32_t(b));
    }

    /**
     * @brief Bitwise OR assignment operator to add flags.
     * @param a The target flag to modify.
     * @param b The flag to add.
     * @return BxDFFlags& Reference to the modified flag.
     */
    inline BxDFFlags& operator|=(BxDFFlags& a, BxDFFlags b) { a = a | b; return a; }

    /**
     * @brief Checks if any flag is set (i.e., not Unset).
     * @param f The flag to check.
     * @return true If the underlying integer value is non-zero.
     * @return false If the flag is Unset.
     */
    inline bool any(BxDFFlags f) { return uint32_t(f) != 0; }

    /**
     * @brief Checks if a specific flag (or set of flags) is present.
     * @param f The base flags to check against.
     * @param bit The specific bit(s) to verify.
     * @return true If the bit is set in f.
     */
    inline bool has(BxDFFlags f, BxDFFlags bit) { return any(f & bit); }

    /**
     * @brief Light transport mode for asymmetric scattering.
     *
     * Distinguishes between light moving from sources (Radiance) or from
     * the camera (Importance). Necessary for handling refraction correctly
     * in bidirectional methods.
     */
    enum class TransportMode {
        Radiance,   ///< Transporting radiance from light sources to the camera.
        Importance  ///< Transporting importance from the camera to light sources.
    };

    /**
     * @brief Result of a BSDF sampling operation.
     *
     * Stores all necessary information generated by the BSDF::sample() method,
     * including the throughput weight, direction, PDF, and specific lobe properties.
     */
    struct BSDFSample {
        /// The evaluated BSDF value (throughput weight) for the sampled direction.
        Spectrum f;

        /// The sampled incident direction in World Space (vector pointing toward the light/source).
        Vector3 wi;

        /// The Probability Density Function (PDF) value for the sampled direction.
        Real pdf = 0;

        /// The specific flags of the BxDF lobe that was actually sampled.
        BxDFFlags flags = BxDFFlags::Unset;

        /**
         * @brief Checks if the sampled interaction was perfectly specular (delta distribution).
         * @return true If the sampled component is specular.
         */
        bool isSpecular() const { return has(flags, BxDFFlags::Specular); }

        /**
         * @brief Checks if the sampling resulted in a reflection event.
         * @return true If the sampled direction lies in the reflection hemisphere.
         */
        bool isReflection() const { return has(flags, BxDFFlags::Reflection); }

        /**
         * @brief Checks if the sampling resulted in a transmission (refraction) event.
         * @return true If the sampled direction lies in the transmission hemisphere.
         */
        bool isTransmission() const { return has(flags, BxDFFlags::Transmission); }
    };

    /**
     * @brief Abstract base class for all materials.
     * * Materials define how light interacts with a surface by providing
     * a Bidirectional Scattering Distribution Function (BSDF).
     */
    class Material {
    public:
        virtual ~Material() = default;

        /**
         * @brief Evaluates the BSDF value f(wo, wi) for a given pair of directions.
         * * @param rec  The surface interaction details (normal, tangents, UVs).
         * @param wo   The outgoing (view) direction in World Space.
         * @param wi   The incident (light) direction in World Space.
         * @param mode The transport mode (usually Radiance).
         * @return Spectrum The BSDF value [1/sr].
         * * @note Following standard PBR conventions, this returns the pure BSDF value.
         * The cosine term (n·wi) is typically applied by the Integrator.
         * For delta distributions (perfect Specular), this returns 0.
         */
        virtual Spectrum eval(const SurfaceInteraction& rec,
            const Vector3& wo, const Vector3& wi,
            TransportMode mode = TransportMode::Radiance) const = 0;

        /**
         * @brief Importance samples a new incident direction wi based on the BSDF.
         * * This method is crucial for variance reduction in path tracing.
         * @param rec    The surface interaction details.
         * @param wo     The outgoing (view) direction in World Space.
         * @param u      A 2D random sample from the RNG [0, 1)^2.
         * @param mode   The transport mode.
         * @return std::optional<BSDFSample> The result of the sampling,
         * or nullopt if sampling fails (e.g., Total Internal Reflection).
         */
        virtual std::optional<BSDFSample> sample(const SurfaceInteraction& rec,
            const Vector3& wo,
            const Point2& u, // ランダムシード
            TransportMode mode = TransportMode::Radiance) const = 0;

        /**
         * @brief Evaluates the Probability Density Function (PDF) for a given direction.
         * * Essential for Multiple Importance Sampling (MIS).
         * @param rec The surface interaction details.
         * @param wo  The outgoing direction.
         * @param wi  The incident direction to evaluate.
         * @return Real The PDF value with respect to solid angle.
         */
        virtual Real pdf(const SurfaceInteraction& rec,
            const Vector3& wo, const Vector3& wi) const = 0;

        // -----------------------------------------------------------
        // Optional Helpers
        // -----------------------------------------------------------

        /**
         * @brief Returns the emitted radiance for area lights.
         * @param rec The surface interaction details.
         * @param wo  The outgoing direction.
         * @return Spectrum The self-emitted radiance (default: black).
         */
        virtual Spectrum emitted(const SurfaceInteraction& rec,
            const Vector3& wo) const {
            return Spectrum(0.0);
        }

        /**
         * @brief Optimization hint to check if the material is perfectly specular.
         */
        virtual bool isSpecular() const { return false; }
    };

} // namespace rayt